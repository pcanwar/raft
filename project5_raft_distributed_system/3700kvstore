#!/usr/bin/env python

import time
import uuid
import sys, socket, select, json
import random
import threading

#Server ID number
my_id = sys.argv[1]

#The ID numbers of all other replicas
replica_ids = sys.argv[2:]

RAND_MIN = 150
RAND_MAX = 300
TIME_SCALE = 1000
HEARTBEAT_INTERVAL = 0.1

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
SOCK_RECV_SIZE = 32768

sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

class StateMachine:

    def __init__(self, id, other_server_ids):
        self.id = id
        self.other_server_ids = other_server_ids
        self.leader_id = 'FFFF'
        #leader, candidate, follower
        self.state = 'follower'
        #latest term server has seen
        self.current_term = 0
        #total votes
        self.votes_count = 0
        #candidate id that received vote in current term
        self.voted_for = None
        #log entries; each entry contains mid, command for state machine, and term
        self.log = []
        #to index by 1
        self.log.append((None, None, self.current_term))
        #index of highest log entry known to be committed
        self.commit_index = 0
        #index of highest log entry applied to state machine
        self.last_applied = 0
        #for each server, index of the next log entry to send to that server
        self.next_index = self.init_next_idx_to_send()
        #for each server, index of highest log entry known to be replicated
        self.match_index = self.init_match_idxs()
        #last time state machine has received an RPC from replica
        self.last_RPC_time = time.time() * TIME_SCALE
        #get random timeout between values
        self.election_timeout = random.uniform(RAND_MIN, RAND_MAX)
        self.start_election_time = 0
        self.key_value_store = {}
        self.queued_client_requests = []

    def run(self):
        global sock, SOCK_RECV_SIZE
        while True:
            raw_msg = sock.recv(SOCK_RECV_SIZE)
            # received nothing
            if len(raw_msg) == 0:
                return
            else:
                msg = json.loads(raw_msg)
                if msg['type'] not in ['get', 'put']:
                    self.check_terms(msg['term'], msg['leader'])
                if self.state == 'follower':
                    if msg['src'] == self.leader_id:
                        self.last_RPC_time = time.time() * TIME_SCALE
                    self.act_as_follower(msg)
                elif self.state == 'candidate':
                    self.act_as_candidate(msg)
                elif self.state == 'leader':
                    self.act_as_leader(msg)

    def print_msg(self, msg, bool=False):
        #bool = False
        if bool:
            print(msg)
        return


    '''
    volatile state on leader
    upon election, leader initializes these values to its last log index + 1
    '''
    def init_next_idx_to_send(self):
        next_idx_to_send = {}
        if self.state == 'leader':
            for server_id in self.other_server_ids:
                next_idx_to_send[server_id] = len(self.log)
        return next_idx_to_send

    '''
    for each server, index of highest log entry known to be replicated
    always initialize to 0
    '''
    def init_match_idxs(self):
        match_index = {}
        if self.state == 'leader':
            for server_id in self.other_server_ids:
                match_index[server_id] = 0
        return match_index

    '''
    all servers:
    if RPC request or response contains term T > current_term:
    set current_term = T, convert to follower
    return True if becomes follower
    '''
    def check_terms(self, T, leader):
        if T > self.current_term:
            self.become_follower(T, leader)

    def client_handler(self, msg):
        global sock

        if self.leader_id == 'FFFF':
            self.queued_client_requests.append(msg)
            #response_to_client = {'src': self.id, "dst": msg['src'], 'leader': self.leader_id, 'type': 'fail',
            #'MID': msg['MID']}
        else:
            response_to_client = {'src': self.id, "dst": msg['src'], 'leader': self.leader_id,
                                  'type': 'redirect', 'MID': msg['MID']}
            sock.send(json.dumps(response_to_client))
            for m in list(self.queued_client_requests):
                response_prev_requests_to_client = {'src': self.id, "dst": m['src'], 'leader': self.leader_id,
                                                    'type': 'redirect', 'MID': m['MID']}
                sock.send(json.dumps(response_prev_requests_to_client))
                self.queued_client_requests.remove(m)


    def apply_commands(self):
        while self.commit_index > self.last_applied:
            self.last_applied += 1
            (mid, command, term) = self.log[self.last_applied]
            command = json.loads(command)
            if command['cmd'] == 'put':
                self.key_value_store[command['key']] = command['value']



    '''
    become a follower
    update the term, RPC time, and leader
    '''
    def become_follower(self, new_term, new_leader):
        global TIME_SCALE

        self.state = 'follower'
        self.last_RPC_time = time.time() * TIME_SCALE
        self.current_term = new_term
        self.voted_for = None
        self.votes_count = 0
        self.leader_id = new_leader
        if self.leader_id == self.id:
            print_msg("THIS SHOULDN'T HAPPEN ABORT ABORT", True)


    '''
    become a candidate, start election
    '''
    def become_candidate(self):
        self.state = 'candidate'
        self.voted_for = None
        self.votes_count = 0
        self.start_election()
        self.print_msg("i %s HAVE BECOME CANDIDATE" % self.id, True)

    def become_leader(self):
        self.state = 'leader'
        self.next_index = self.init_next_idx_to_send()
        self.match_index = self.init_match_idxs()
        self.leader_id = self.id
        self.voted_for = None
        self.votes_count = 0
        entries = []
        self.send_regular_heartbeat(entries)
        self.print_msg("i %s HAVE BECOME LEADER" % self.id, True)

    '''
    starts election. Candidate increments term, votes for itself
    '''
    def start_election(self):
        global TIME_SCALE, RAND_MIN, RAND_MAX
        #increment term at start of each election
        self.current_term += 1
        #votes for itself
        self.votes_count += 1
        self.voted_for = self.id
        #set leader id to None
        self.leader_id = 'FFFF'
        #reset election timer
        self.election_timeout = random.uniform(RAND_MIN, RAND_MAX)
        self.start_election_time = time.time() * TIME_SCALE
        #send out request vote RPCs
        self.send_vote_requests()
        #process the results
        #self.process_vote_results(start_election_time)

    def send_vote_requests(self):
        global sock

        for server_id in self.other_server_ids:
            #indexed by 1
            last_log_index = len(self.log) - 1
            (mid, command, last_log_term) = self.log[last_log_index]
            request_for_vote = {'src': self.id, 'dst': server_id, 'leader': self.leader_id,
            'type': 'vote_request', 'MID': str(uuid.UUID), 'term': self.current_term,
            'last_log_index': last_log_index, 'last_log_term': last_log_term}
            sock.send(json.dumps(request_for_vote))

    def send_vote_response(self, msg, term, vote_granted):
        global sock

        vote_response = {'src': self.id, 'dst': msg['src'], 'leader': self.leader_id,
        'type': 'vote_response', 'MID': str(uuid.UUID), 'term': term,
        'vote_granted': vote_granted}
        sock.send(json.dumps(vote_response))

    def append_handler(self, msg):
        response = {'src': self.id, "dst": msg['src'], 'leader': self.leader_id, 'term': self.current_term,
                    'type': 'append_response', 'MID': msg['MID'], 'prev_log_index': msg['prev_log_index'],
                    'prev_log_term': msg['prev_log_term'], 'entries': msg['entries'], 'accept_request': False}

        if len(msg['entries']) == 0:
            #TODO maybe heartbeats should respond?
            self.become_follower(msg['term'], msg['leader'])
            return
        else:
            if self.current_term > msg['term']:
                sock.send(json.dumps(response))
                return
            try:
                (prev_mid, prev_command, prev_term) = self.log[msg['prev_log_index']]
                if prev_term != msg['prev_log_term']:
                    sock.send(json.dumps(response))
                    return
            except:
                sock.send(json.dumps(response))
                return



            #entry = msg['entries'][0]



    def act_as_follower(self, msg):

        #have we timed out
        if time.time() * TIME_SCALE - self.last_RPC_time >= self.election_timeout:
            #TODO We'll talk about this
            if self.voted_for is None:
                self.print_msg("i %s become candidate 1" % self.id, True)
                self.become_candidate()
                return

        if msg['type'] in ['get', 'put']:
            self.client_handler(msg)
            return

        self.election_timeout = random.uniform(RAND_MIN, RAND_MAX)

        if msg['type'] == 'append_request':
            self.append_handler(msg)
        elif msg['type'] == 'vote_request':
            if msg['term'] < self.current_term:
                self.send_vote_response(msg, self.current_term, False)
            elif self.voted_for is None or self.voted_for == msg['src']:
                last_log_index = len(self.log) - 1
                (mid, command, last_log_term) = self.log[last_log_index]
                if last_log_index <= msg['last_log_index'] and last_log_term <= msg['last_log_term']:
                    self.voted_for = msg['src']
                    self.print_msg("i %s vote for %s 2" % (self.id, msg['src']), True)
                    self.send_vote_response(msg, msg['term'], True)
                else:
                    self.send_vote_response(msg, self.current_term, False)
            else:
                self.send_vote_response(msg, self.current_term, False)


    '''
    process the received votes:
    receive responses, if N/2 + 1 then become leader and send heartbeat
    if tie, timeout and restart election
    if failed, become follower
    '''
    def act_as_candidate(self, msg):

        N = len(self.other_server_ids)
        majority_votes = N / 2 + 1

        #if we've timed out
        if time.time() * TIME_SCALE - self.start_election_time >= self.election_timeout:
            #split vote scenario
            self.become_candidate()
        else:
            #checks if received enough votes
            #if gathered majority votes, become leader
            if self.votes_count >= majority_votes:
                self.become_leader()
                return
            #receive more messages
            if msg['type'] in ['get', 'put']:
                self.client_handler(msg)
                return
            elif msg['type'] == 'vote_response':
                if msg['vote_granted']:
                    #collect vote
                    self.votes_count += 1
                    if self.votes_count >= majority_votes:
                        self.become_leader()
                        return
            #don't vote because we're a candidate
            elif msg['type'] == 'vote_request':
                self.send_vote_response(msg, self.current_term, False)
            elif msg['type'] == 'append_request':
                self.append_handler(msg)
    
    '''
    Appends new command to its log as a new entry
    '''
    def append_new_log_entry(self, command, mid):
        # TODO should entry contain MID ?
        # TODO do i care about duplicate?
        entry = (mid, command, self.current_term)
        self.log.append(entry)
        return entry


    def act_as_leader(self, msg):
        if msg['type'] == 'get':
            key = msg['key']
            value = self.key_value_store.get(key)
            if value is None:
                value = ''
            response_to_client = {'src': self.id, 'dst': msg['src'], 'leader': self.id,
                                    'type': 'ok', 'MID': msg['MID'], 'value': value}
            sock.send(json.dumps(response_to_client))
            '''
            command = json.dumps({'cmd': 'get', 'key': key})
            entry = self.append_new_log_entry(command, msg['MID'])
            entries.append(entry)
            self.send_append_request(entry)
            '''
        elif msg['type'] == 'put':
            key = msg['key']
            value = msg['value']
            self.key_value_store[key] = value
            response_to_client = {'src': self.id, 'dst': msg['src'], 'leader': self.id,
                                    'type': 'ok', 'MID': msg['MID']}
            sock.send(json.dumps(response_to_client))
            '''
            command = json.dumps({'cmd': 'get', 'key': key, 'value': value})
            entry = self.append_new_log_entry(command, msg['MID'])
            entries.append(entry)
            self.send_append_request(entry)
            '''
        '''
        else:
            if self.check_terms(msg['term'], msg['leader']):
                self.print_msg(msg, True)
                self.print_msg("i %s HAVE BECOME FOLLOWER" % self.id, True)
        '''

    def send_append_request(self, entries):
        prev_log_index = self.commit_index
        (prev_mid, prev_command, prev_log_term) = self.log[prev_log_index]
        for server_id in self.other_server_ids:
            append_entry_RPC = {'src': self.id, 'dst': server_id, 'leader': self.id,
            'type': 'append_request', 'MID': str(uuid.UUID), 'term': self.current_term,
            'entries': entries, 'leader_commit': self.commit_index, 
            'prev_log_index': prev_log_index, 'prev_log_term': prev_log_term}
            sock.send(json.dumps(append_entry_RPC))
        

            
    def send_regular_heartbeat(self, entries):
        global HEARTBEAT_INTERVAL
        self.send_append_request(entries)
        threading.Timer(HEARTBEAT_INTERVAL, self.send_regular_heartbeat, [entries]).start()


def main():
    global my_id, replica_ids

    my_server = StateMachine(my_id, replica_ids)
    my_server.run()

if __name__ == "__main__":
    main()