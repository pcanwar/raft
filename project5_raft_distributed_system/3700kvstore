#!/usr/bin/env python

import sys, socket, select, time, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)

last = 0

class StateMachine:

    def __init__(self, id, other_server_ids):
        self.id = id
        self.leader_id = None
        self.state = 'follower'
        self.current_term = 0
        self.voted_for = None
        self.log[] = list()
        self.commit_idx = 0
        self.last_applied = 0
        self.next_idx[] = list()
        self.match_idx[] = list()
        self.last_RPC_time = time.time()
        self.election_timeout = randint(150, 300)

    '''
    resets the timeout when an RPC is received
    '''
    def reset_timeout(self):
        self.election_timeout = randint(150, 300)
        self.last_RPC_time = time.time()

    '''
    check if this server has timed out
    '''
    def has_timed_out(self):
        cur_time = time.time()
        return cur_time - self.last_RPC_time > self.election_timeout

    def start_election(self):
        self.election_timeout = randint(150, 300)
        start_election_time = time.time()
        self.become_candidate()
        self.request_votes()

    def become_candidate(self):
        self.state = 'candidate'
        self.current_term += 1
        self.votes_count += 1

def main():
    global last, my_id, replica_ids, sock, SOCK_RECV_SIZE

    # Your ID number
    my_id = sys.argv[1]
    sock.connect(my_id)

    # The ID numbers of all the other replicas
    replica_ids = sys.argv[2:]
    my_server = StateMachine(my_id, replica_ids)

    while True:
        ready = select.select([sock], [], [], 0.1)[0]

        if sock in ready:
            msg_raw = sock.recv(SOCK_RECV_SIZE)

            if len(msg_raw) == 0: continue
            msg = json.loads(msg_raw)

            # basic support for responding to client get() and put() requests
            # {"src": "<ID>", "dst": "<ID>", "leader": "<ID>", "type": "fail", "MID": "<a unique string>"}
            if msg['type'] in ['get', 'put']:
                response = {'src': msg['dst'], "dst": msg['src'], "leader": msg['leader'], "type": "fail", "MID": msg['MID']}
                sock.send(json.dumps(response))

            # Handle noop messages. This may be removed from your final implementation
            elif msg['type'] == 'noop':
                print '%s received a NOOP from %s' % (msg['dst'], msg['src'])

        clock = time.time()
        if clock - last > 2:
            # Send a no-op message to a random peer every two seconds, just for fun
            # You definitely want to remove this from your implementation
            msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
            sock.send(json.dumps(msg))
            print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
            last = clock


if __name__ == "__main__":
    main()