#!/usr/bin/python

import socket
import sys
from urlparse import urlparse
from HTMLParser import HTMLParser
import time
import zlib

USERNAME = "1622045"
PASSWORD = "14YURN58"

fakebook_url = urlparse('http://fring.ccs.neu.edu/fakebook/')
login_url = urlparse('http://fring.ccs.neu.edu/accounts/login/?next=/fakebook/')
full_login_path = "/accounts/login/?next=/fakebook/"
HOST = fakebook_url.netloc 
# fakebook_url.netloc fring.ccs.neu.edu
FAKEBOOK_PATH = fakebook_url.path
LOGIN_PATH = login_url.path
HTTP_VERSION = "HTTP/1.1"

PORT = 80
HOST_PORT = (HOST, PORT)

hundred_count = 0
path_map = {}
paths_tovisit = {}
num_visit = {}
secret_flags = []

csrf = ''
session_id = ''

class PageParser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)

    def handle_starttag(self, tag, attrs):
        global paths_tovisit, secret_flags, path_map, hundred_count
        # find links in the page
        if tag == 'a':
            for attr, val in attrs:
                if attr == 'href':
                    # only add to tovisit list if the url has not been visited
                    # doesn't exist in tovisit list already, and it's valid
                    val_path = urlparse(val).path
                    #SP: ask about this
                    if val_path not in set(paths_tovisit) and val.startswith('/fakebook'):
                        #print("found: %s" % val_path)
                        add_path(val_path)
                        #print("add a new valid url to visit: %s" % val_path)
        
        


    def handle_endtag(self, tag):
        global paths_tovisit
        #print("end tag: " + str(tag))
        if tag == "html":
            pass

    def handle_data(self, data):
        global secret_flags, csrf, session_id
        #print("Data: " + data)
        if "csrftoken" in data:
            csrf = data.split("csrftoken=")[1].split(";")[0]

        if "sessionid" in data:
            session_id = data.split("sessionid=")[1].split(";")[0]
        if "FLAG:" in data:
            flag = data.split("FLAG:")[1].split("</h2>")[0]
            secret_flags.append(flag)
            print(flag)
            print("FLAG #" + str(len(secret_flags)))


def add_path(val_path):
    global paths_tovisit, hundred_count, path_map
    paths_tovisit[val_path] = False
    pathList = []
    try:
        pathList = path_map[str(hundred_count)]
    except:
        pathList.append(val_path)
        path_map[str(hundred_count)] = pathList
    if len(pathList) < 100: 
        pathList.append(val_path)
        path_map[str(hundred_count)] = pathList
    elif len(pathList) == 100:
        hundred_count+=1
        pathList = []
        pathList.append(val_path)
        path_map[str(hundred_count)] = pathList
"""
receive HTTP responses using the socket
"""
def recv_response(sock, timeout=1/100):
    data = ''
    data_buffer = ""
    sock.settimeout(.3)
    while True:
        try:
            data = sock.recv(9000)

            if not data:
                break
            data_buffer+=data
        except:
            break

    sock.close()
    return data_buffer

    

def login_GET():
    global full_login_path, HTTP_VERSION, HOST, HOST_PORT

    request = request = request = '''\
GET %s %s
Host: %s
Accept-Encoding: gzip

''' % (full_login_path, HTTP_VERSION, HOST)
    #sock.sendall(request)
    #print("============================LOGIN REQUEST============================")
    #print(request)
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(HOST_PORT)
        sock.sendall(request)
        response = recv_response(sock)
        #print("============================LOGIN RESPONSE============================")
        #print(response)
        return response
    except socket.error as e:
        #print 'ERROR: Failed to create socket! $s' %e
        exit(1)

def cookie_GET(path):
    global HTTP_VERSION, HOST, csrf, session_id, HOST_PORT

    #print("RECEIVED PATH: " + path)

    #request = "GET %s %s\nHost: %s\n" % (path, HTTP_VERSION, HOST)
    #request+= "Cookie: csrftoken=%s; sessionid=%s\n\n" (csrf, session_id)
    request = '''\
GET %s %s
Host: %s
Accept-Encoding: gzip
Cookie: csrftoken=%s; sessionid=%s

''' % (path, HTTP_VERSION, HOST, csrf, session_id)
    #sock.sendall(request)
    #print("============================GET REQUEST============================")
    #print(request)
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(HOST_PORT)
        sock.sendall(request)
        response = recv_response(sock)
        #print("============================GET RESPONSE============================")
        #print(response)
        return response
    except socket.error as e:
        #print 'ERROR: Failed to create socket! $s' %e
        exit(1)

def login_POST(path):
    global HTTP_VERSION, HOST, csrf, session_id, USERNAME, PASSWORD, HOST_PORT

    data = "username=%s&password=%s&csrfmiddlewaretoken=%s&next=%%2Ffakebook%%2F" % (USERNAME, PASSWORD, csrf)
    #request = "POST %s %s\nHost: %s\n" % (path, HTTP_VERSION, HOST)
    #request += "Content-Length: %d\nCookie: csrftoken=%s; sessionid=%s\n\n" % (len(data), csrf, session_id)
    #request += "%s\n" % (data)
    request = '''\
POST %s %s
Host: %s
Accept-Encoding: gzip
Content-Length: %d
Cookie: csrftoken=%s; sessionid=%s

%s
''' % (path, HTTP_VERSION, HOST, len(data), csrf, session_id, data)
    #print("============================POST REQUEST============================")
    #print(request)
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(HOST_PORT)
        sock.sendall(request)
        response = recv_response(sock)
        #print("============================POST RESPONSE============================")
        #print(response)
        return response
    except socket.error as e:
        #print 'ERROR: Failed to create socket! $s' %e
        exit(1)

def login():
    global HOST_PORT, LOGIN_PATH

    #sock.connect(HOST_PORT)

    get_response = login_GET()
    crawl_webpage(get_response)
    post_response = login_POST(LOGIN_PATH)
    crawl_webpage(post_response)
    handle_http_status_codes(post_response, LOGIN_PATH)

def crawl_webpage(response):
    global csrf, session_id

    parser = PageParser()
    message = []
    compressed = ""
    try:
        message = response.split("\r\n\r\n")
        compressed = message[1]
        response = zlib.decompress(compressed, zlib.MAX_WBITS|32)
        response = message[0] + response
    except:
        print(response)
    parser.feed(response)
    # csrf token and session id should be updated
    #print '==========================token and session======================'
    #print csrf
    #print session_id

def handle_http_status_codes(response, path):
    status_code = ''
    try:
        status_code = response.split(' ')[1]
    except:
        status_code = '500'
    #print(str(status_code))
    if status_code == '200':
        pass
    if status_code == '301' or status_code == '302':
        new_path = str(urlparse(response.split('Location: ')[1].split('\n')[0]).path).rstrip('\r')
        #print ("NEW LOCATION: " + new_path)
        #response = cookie_GET(new_path)
        #crawl from here?
        if new_path not in paths_tovisit:
            add_path(new_path)
        paths_tovisit[path] = True
        # TODO make get (cookie) request again
        # TODO remove url from tovisit, add to visited
    if status_code == '403' or status_code == '404':
        paths_tovisit[path] = True

    if status_code == '500':
        response = cookie_GET(path)
        handle_http_status_codes(response, path)
    return status_code


def main():
    
    login()
    counter = 0
    while len(secret_flags) < 5:
        pathList = path_map[str(counter)]
        for path in pathList:
            if len(secret_flags) >= 5:
                break
            if not paths_tovisit[path]:
                response = cookie_GET(path)
                status_code = handle_http_status_codes(response, path)
                if status_code == '200':
                    crawl_webpage(response)
                    paths_tovisit[path] = True
        counter+=1

    sys.exit(0)


if __name__ == "__main__":
    main()