#!/usr/bin/python -u    
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json
import time

forward_table = {}
sockets = []
queued_packets = []
recv_bpdus_from = []
my_bid = sys.argv[1]
root = my_bid
root_port = -1
data_fwd = False
bridge_up = -1
designated_ports = []
cost = 0
des_assign_time = 1000 #constant
data_send_time = 1750 #constant
bpdu_bw_time = 50 #constant

# pads the name with null bytes at the end
def pad(name):
        result = '\0' + name
        while len(result) < 108:
                result += '\0'
        return result
    
def recv_BPDU(packet, port):
    global bridge_up, designated_ports, root, cost, root_port
    my_bid_in_b16 = int(my_bid, 16)  # my unique bridge id
    recv_bid_in_b16 = int(packet['source'], 16)  # the bridgeid of where the BPDU came from
    recv_rbid_in_b16 = int(packet['message']['root'], 16)  # The root that the BPDU's source is using
    my_rbid_in_b16 = int(root, 16) # The root I am using
    
    if packet['source'] == my_bid and packet['message']['port'] < port:
        recv_bpdus_from.append(port)
        return
    elif packet['source'] == my_bid:
        return
    
    recv_bpdus_from.append(port)
    now = int(round(time.time() * 1000))
    if now - bridge_up > des_assign_time and my_bid_in_b16 < recv_bid_in_b16 and port not in designated_ports:
        print 'Designated port: %s/%d' % (my_bid, port)
        designated_ports.append(port)
        return
    
    if recv_rbid_in_b16 >= my_rbid_in_b16 and packet['message']['cost'] >= cost:
        pass
    else:
        new_root = packet['message']['root']
        cost = packet['message']['cost']
        
        if root != new_root:
            root = new_root
            print 'New root: %s/%s' % (my_bid, root)
        if port != root_port:
            print 'Root port: %s/%d' % (my_bid, port)
            root_port = port
        broadcast_BPDU()
        
def broadcast_BPDU():
    global sockets
    for soc in sockets:
        bpdu_msg = {"source": my_bid, "dest": "ffff", "type": "bpdu",
                "message":{"id":my_bid, "root": root, "cost": cost, "port" : sockets.index(soc)}}
        soc.send(json.dumps(bpdu_msg))

def forward_packet(port, packet):
    global forward_table
    forward_table[packet['source']] = port
    if packet['dest'] in forward_table and forward_table[packet['dest']] != port:
        sockets[forward_table[packet['dest']]].sendall(json.dumps(packet))
        print('Forwarding message %d to port %d' % (packet['message']['id'], forward_table[packet['dest']]))
    elif packet['dest'] in forward_table and forward_table[packet['dest']] == port:
        print 'Not forwarding message'
    else:
        print 'Broadcasting message %d to all ports' % packet['message']['id']
        for i in range(len(sockets)):
            socket_enabled = i in designated_ports or i not in recv_bpdus_from or i == root_port
            if (socket_enabled and i != port):
                sockets[i].sendall(json.dumps(packet))
                
def handle_packets():
    global queued_packets, recv_bpdus_from, designated_ports
    now = int(round(time.time() * 1000))
    for port in range(len(queued_packets)):
        port_enabled = port == root_port or port not in recv_bpdus_from or port in designated_ports
        for packet in queued_packets[port]:
            if packet['type'] == 'bpdu':
                recv_BPDU(packet, port)
                queued_packets[port].remove(packet)
            elif now - bridge_up > data_send_time:
                if port_enabled:
                    print 'Received message %d on port %d from %s to %s' % (packet['message']['id'], port, packet['source'], packet['dest'])
                    forward_packet(port, packet)
                queued_packets[port].remove(packet)
 
    
def main():
    global sockets, queued_packets, bridge_up, bpdu_bw_time
    id = sys.argv[1]
    LAN = sys.argv[2:]
    
    # creates sockets and connects to them
    for x in range(len(LAN)):
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            s.connect(pad(LAN[x]))
            sockets.append(s)
            queued_packets.append([])
    
    
    print "Bridge " + id + " starting up\n"
    bridge_up = int(round(time.time() * 1000))
    last_bpdu = bridge_up
    broadcast_BPDU()
    # Main loop
    while True:
        
        now = int(round(time.time() * 1000))
        if now - last_bpdu >= bpdu_bw_time:
            broadcast_BPDU()
            last_bpdu = now
        
        # Calls select with all the sockets; change the timeout value (1)
        ready, ignore, ignore2 = select.select(sockets, [], [], 1)
 
        # Reads from each fo the ready sockets
        for x in ready:
                data = x.recv(1500)
                data = json.loads(data)
                port = sockets.index(x)
                queued_packets[port].append(data)
                
        handle_packets()
    
if __name__ == "__main__":
    main()

