#!/usr/bin/python -u

import sys
import socket
import json
import time
import datetime
import select
import math
from packets import *

# constant
DATA_SIZE = 1000
TIMEOUT = 30
PACKET_TIMEOUT = .5

# global
data_to_be_acked = []
seq_number = 0
time_of_last_ack = 0;

IP_PORT = sys.argv[1]

HOST = IP_PORT[0:IP_PORT.find(":")]
PORT = int(IP_PORT[IP_PORT.find(":")+1:])
HOST_PORT = (HOST, PORT)
INIT_CWND = 20
cwnd = INIT_CWND

#TCP Cubic constants
time_of_last_packet_drop = time.time() - 1
prev_cwnd_max = cwnd
SCALE = 1
SCAL_FRAC = .5

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(TIMEOUT)
sock.bind((HOST, PORT+1))
#ack_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
#ack_sock.bind((HOST, PORT+1))



"""
    Logs the message to stderr
    @param the message to be logged
"""
def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")


"""
    Sets/Updates the congestion window size based on the CUBIC function
"""
def set_cwnd():
    global time_of_last_packet_drop, prev_cwnd_max, SCALE, SCAL_FRAC, cwnd
    K = (prev_cwnd_max * SCAL_FRAC / SCALE) ** (1. / 3)
    t = time.time() - time_of_last_packet_drop
    new_window = (SCALE*((t - K) ** 3)) + prev_cwnd_max
    cwnd = max(math.floor(new_window), INIT_CWND)
    #log('k is %d, time diff is %d, prev max is %d' % (K, t, prev_cwnd_max))
    #log('set cwnd to %d' % cwnd)


"""
    constructs a single packet based on the given data and offset
    @param data - the data content of the packet
    @param offset - the offset of the given data compare to the input chunk
    @return the constructed packet and the new offset
"""
def construct_packet(data, offset):
    # if have more data than DATA_SIZE bytes
    if len(data) > offset + DATA_SIZE:
        # extract DATA_SIZE bytes of data
        result = data[offset:offset + DATA_SIZE]
        # construct a sendPacket(seq_num, data, size, timeout, ack, iseof)
        packet = SendPacket(offset, result, len(result), PACKET_TIMEOUT + time.time(), False, False)
        # update offset
        offset += DATA_SIZE
    # less than DATA_SIZE bytes left
    else:
        # extract the rest of the data
        result = data[offset:]
        # construct a sendPacket(seq_num, data, size, timeout, ack, iseof)
        packet = SendPacket(offset, result, len(result), PACKET_TIMEOUT + time.time(), False, True)
        # update the offset
        offset += len(result)


    return packet, offset

"""
    Constructs a list of packets from the data given,
    if len(data) < 1500, just return [packet]
    @param data - the data to use to construct packets
    @param offset - the offset of the data, keeps track of the current byte location
    @return Array[SendingPacket] - the packets constructed from the given data
"""
def construct_packets_from_data(data, offset):
    packets = []
    while offset < len(data):
        # construct packet w/ 1500 or fewer bytes
        # increment index by how big the packet is
        # repeat
        new_packet, offset = construct_packet(data, offset)
        packets.append(new_packet)

    return packets

"""
    Read input lines and construct data packets (size < 1500 bytes)
    @return Array[SendingPacket] - the packets constructed from the given data
"""
def read_data():
    data_set = ""
    # read in each line and store the lines into data_set list
    for line in sys.stdin:
        data_set += line

    packets_to_send = []
    # construct packets for the input data
    offset = 0
    packets_from_data = construct_packets_from_data(data_set, offset)
    # add the packet(s) to the list of packets
    packets_to_send.extend(packets_from_data)

    return packets_to_send


"""
    Receives acknowledgments of packets from the receiver
"""
def recv_acks():
    global sock, HOST_PORT, time_of_last_ack
    ready, ignore1, ignore2 = select.select([sock], [], [], .1)
    for s in ready:
        msg, addr = s.recvfrom(1000)
        try:
            ack = json.loads(msg)
            log('[recv ack]  %d' %  ack['seq_num'])
            for packet in list(data_to_be_acked):
                if packet.get_seq_num() == ack['seq_num']:
                    packet.set_acked()
                    data_to_be_acked.remove(packet)
                    time_of_last_ack = time.time()
        except (ValueError, KeyError, TypeError) as e:
            print("recevied corrupted ACK")
            print(ack)
            raise e


"""
    Sends data to the receiver
    @param the list of packets to send
    @return the updated list of tobesent data packets, which contains the packets
    that the program did not successfully send through
"""
def send_data(packets_to_send):
    global HOST_PORT, cwnd, data_to_be_acked
    while (len(packets_to_send) > 0) and (len(data_to_be_acked) < cwnd):
        packet = packets_to_send[0]
        # update new timeout time for the packet when send
        packet.set_timeout(PACKET_TIMEOUT + time.time())
        bytes_sent = sock.sendto(packet.get_json(), HOST_PORT)
        if (bytes_sent >= packet.size):
            log('[send data] %d (%d)' % (packet.get_seq_num(), packet.size))
            del packets_to_send[0]
            data_to_be_acked.append(packet)
        else:
            log('[ERROR] packet send failed!')
    
    return packets_to_send


"""
    Checks if any packets are dropped when sending through (reached timeout before receiving an ACK). If a packet is timedout, then resend the packet.
    @param list of packets to be sent
    @return the updated list of packets to be sent (size should be the same or larger))
"""
def check_timeouts(packets_to_send):
    global data_to_be_acked, time_of_last_packet_drop, cwnd, prev_cwnd_max
    result = []
    for packet in list(data_to_be_acked):
        if packet.is_timed_out():
            log('packet %d timed out, resending' % packet.get_seq_num())
            time_of_last_packet_drop = time.time()
            prev_cwnd_max = cwnd
            data_to_be_acked.remove(packet)
            packet.set_timeout(time.time() + PACKET_TIMEOUT)
            result.append(packet)
    return result

"""
    The sender, executes the program
"""
def main():
    global time_of_last_ack
    time_of_last_ack = time.time()
    start = time.time()
    packets_to_send = []
    while True:
        packets_to_send.extend(read_data())
        packets_to_send = send_data(packets_to_send)
        recv_acks()
        packets_to_send.extend(check_timeouts(packets_to_send))
        set_cwnd()
        #if len(packets_to_send) == 0 and len(data_to_be_acked) == 0:

        if time.time() > time_of_last_ack + (5 * PACKET_TIMEOUT) or (len(packets_to_send) == 0 and len(data_to_be_acked) == 0):
        #if time.time() > start + 5:
            log('[completed]')
            break

if __name__ == "__main__":
    main()



