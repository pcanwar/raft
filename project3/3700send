#!/usr/bin/python -u

import sys
import socket
import json
import time
import datetime
import select
from packets import *

# constant
DATA_SIZE = 1500

# global
data_to_send = []
data__to_be_acked = []
seq_number = 0

IP_PORT = sys.argv[1]
HOST = IP_PORT[0:IP_PORT.find(":")]
PORT = int(IP_PORT[IP_PORT.find(":") + 1:])
HOST_PORT = (HOST, PORT)
TIMEOUT = 30
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
"""
    sends a packet to a designated connection
    @param packet_to_send - SendPacket - the packet we're sending
"""
def send_packet(packet_to_send):
    sock.sendto(packet_to_send.get_json(), HOST_PORT)

def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

"""
    constructs a single packet based on the given data and offset
    @param data - the data content of the packet
    @param offset - the offset of the given data compare to the input chunk
    @return the constructed packet and the new offset
"""
def construct_packet(data, offset):
    # if have more data than 1500 bytes
    if len(data) > offset + DATA_SIZE:
        # extract 1500 bytes of data
        result = data[offset:offset + DATA_SIZE]
        # update offset
        offset = offset + DATA_SIZE
        # construct a sendPacket(size, timeout, seq_num, data, iseof)
        packet = SendPacket(len(result), TIMEOUT + time.time(), offset, result, False)

    # less than 1500 bytes left
    else:
        # extract the rest of the data
        result = data[offset:]
        # update the offset
        offset = len(data)
        # construct a sendPacket(size, timeout, seq_num, data, iseof)
        packet = SendPacket(len(result), TIMEOUT + time.time(), offset, result, True)

    log("extracting data for one packet: %s" % result)
    log("new offset: %d" % offset)
    log("constructed a packet %s" % packet)
    return packet, offset

"""
    Constructs a list of packets from the data given,
    if len(data) < 1500, just return [packet]
    @param data - the data to use to construct packets
    @return Array[SendingPacket] - the packets constructed from the given data
"""
def construct_packets_from_data(data_line):
    offset = 0
    packets = []
    while offset < len(data_line):
        # construct packet w/ 1500 or fewer bytes
        # increment index by how big the packet is
        # repeat
        new_packet, offset = construct_packet(data_line, offset)
        packets.append(new_packet)

    return packets

"""
    Read input lines and construct data packets (size < 1500 bytes)
    @return Array[SendingPacket] - the packets constructed from the given data
"""
def read_data():
    data_set = []
    # read in each line and store the lines into data_set list
    for line in sys.stdin:
        data_set.append(line)

    packets_to_send = []
    # construct a packet for each line
    for data_line in data_set:
        # stuff each line to packet(s)
        packets_from_data = construct_packets_from_data(data_line)
        # add the packet(s) to the list of packets
        packets_to_send.extend(packets_from_data)

    return packets_to_send

    """
    data = sys.stdin.read(DATA_SIZE)
    if len(data) > 0:
        # seq, if acked
        sending_packet = SendingPacket(len(data), time.time() + TIMEOUT, LAST_SEQ + len(data), data, False)
    """

def recv_acks():
    global sock

    log('in recv_acks')
    ready, ignore1, ignore2 = select.select([sock], [], [], .1)
    for s in ready:
        log(str(s.recvfrom(1000)))

def send_data():
    pass

def main():


    # loop
    # reads data and enqueues
    # sends data from enqueued
    # receive acks
    while True:
        #read_data()
        #send_data()
        recv_acks()

if __name__ == "__main__":
    main()



