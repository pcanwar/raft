#!/usr/bin/python

import sys
import socket
import time
import datetime
import select
import json
from packets import *

MSG_SIZE = 1500
TIMEOUT = 30
seq = 0
eof = False
max_seq = -1



"""
    Logs the message to stderr
    @param the message to be logged
"""
def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

# Bind to localhost and an ephemeral port
UDP_IP = "127.0.0.1"
UDP_PORT = 0

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.bind((UDP_IP, UDP_PORT))
sock.settimeout(TIMEOUT)

# Get port we bound to
UDP_PORT = sock.getsockname()[1]
log("[bound] " + str(UDP_PORT))

buffered_packets = []


"""
    Gets the status of the received message, whether it is accepted(inorder/outoforder) or IGNORED(duplicate)
    @param the data received in JSON format
"""
def get_status(data_json):
    recv_seq = data_json['seq_num']
    if recv_seq == seq:
        return 'ACCEPTED (in-order)'
    elif recv_seq > seq:
        return 'ACCEPTED (out-of-order)'
    elif recv_seq < seq:
        return 'IGNORED'


"""
    Listens to the socket and receives packets from the socket.
    Identifies if the packet is the last packet of the file or not,
    Buffers the received packet if it is out-or-order.
"""
def receive_enqueue_ack():
    global buffered_packets, eof, max_seq
    result = sock.recvfrom(MSG_SIZE)
    if result:
        (data, addr) = result

        try:
            data_json = json.loads(data)
            ack = AckPacket(data_json['seq_num'])
            sock.sendto(json.dumps(ack.as_json()), (UDP_IP, UDP_PORT+1))
            # if at the end of the message
            if data_json['eof']:
                status = get_status(data_json)
                log('[recv data] %d (%d) %s' % (data_json['seq_num'], data_json['size'], status))
                eof = True
                max_seq = data_json['seq_num'] + data_json['size']
                buffered_packets.append(data_json)
                return
                #sys.exit(0)
            # if not at the end of the message
            if data_json['data']:
                status = get_status(data_json)
                log('[recv data] %d (%d) %s' % (data_json['seq_num'], data_json['size'], status))
                buffered_packets.append(data_json)
                
                #sys.stdout.write(data_json['data'])
        except (ValueError, KeyError, TypeError) as e:
            log('[recv corrupt packet]')
            print data_json
            raise e


"""
    Iterated through the list of buffered packets and determines if each packet is in-order or out-or-order
"""
def process():
    global seq
    acted = True
    while acted:
        acted = False
        for packet in list(buffered_packets):
            # if the packet is what we expected, in-order, then process it
            if packet['seq_num'] == seq:
                #log('read packet %d, waiting for packet %d' % (packet['seq_num'], seq + packet['size']))
                seq += packet['size']
                acted = True
                sys.stdout.write(packet['data'])
                buffered_packets.remove(packet)
            # if the packet is duplicate, then drop it
            elif packet['seq_num'] < seq:
                buffered_packets.remove(packet)

# Now listening for packets
while True:
    # receive/enqueue data
    receive_enqueue_ack()
    # process data/send ack
    process()
    # gracefully exit the program is the entire file is transmitted
    if len(buffered_packets) == 0 and eof and max_seq == seq:
        log('[completed]')
        break
        
"""
    else:
        log("[ERROR] socket timed out after %d seconds!" % TIMEOUT)
        sys.exit(-1)
"""
